# 进程与线程
## 进程
- 一个运行的程序就是一个进程
- 进程三个特性
    1. **独立性**：不同进程之间有自己独立的内存空间
    2. **动态性**：程序是静止的，运行中的程序是动态的，进程是运行中的程序
    3. **并发性**：CPU是分时执行的，CPU时间片与内存空间按一定时间间隔，轮流地切换给各进程使用 
## 线程
- 一个进程包含多个线程，线程属于进程，线程不能独立存在
    - 基本不占用内存空间和资源，动态性，并发性
    1. 一个进程可以包括多个线程
    2. 线程不能独立存在
    3. 同一进程中的不同线程之间通信比较简单，因为他们会共享同一块内存空间
    4. 线程也具备动态性和并发性

- 多线程好处
    1. 多线程基本不占用内存和资源，节约内存
    2. 可以并发执行
    3. 线程之间容易进行通信，效率高
    4. java对多线程支持完美

## java创建线程类三种方式
1. 继承Thread类来创建多线程类，重写Thread中的run方法，调用start方法，相当于通知CPU，线程已经就绪，CPU在合适的时间点调用该线程的run方法。程序中的main方法称为主线程
2. 实现Runnable接口，并重写run方法，创建实例之后，将实例包装成Thread实例，继续调用start方法让线程就绪。因为Runnable是一个函数式接口，因此可以使用Lambda表达式代替
3. 实现Callable接口，重写该接口的call方法，run方法没有返回值，而call方法有返回值
    - 创建Callable实例，重写call方法
    - 将Callable实例传入FutureTask构造器中，得到FutureTask实例
    - 创建Thread实例，将FutureTask实例传入Thread构造器中，再让线程就绪

- 三种创建线程方法区别：
    1. 相对而言，继承Thread创建线程代码最简单
    2. 如果我们的类继承了Thread，就不能再去继承其他类，因为java是单继承，如果我们通过实现接口Runnable或者Callable来创建线程，我们的类还有权利去继承其他类
    3. 实现Runnable或者Callable接口，可以让多个线程共享同一份资源
    4. 当需要线程执行完毕之后有返回值，需要使用Callable

## 线程中的常用方法
1. currentThread：静态方法，获取当前线程
2. getName：获取线程名字，实例方法
3. getId：获取线程Id，线程id是唯一
4. setPriority：设置线程优先级，如果不设置，默认为5，值越大，说明被CPU调用*机会*越大
5. setName：设置线程名字，没有setId方法，线程的Id是自动分配的，并且是唯一的，不需要人为设置
6. getPriority：获取线程优先级
7. start：让线程就绪
8. stop：结束当前线程
9. run：线程主方法，线程在执行的时候，就是在执行run方法
10. sleep：让线程处于睡眠状态 

## 通过synchronized实现线程安全
1. 方法使用synchronized修饰，只有一个线程可以进入方法体中，当该线程执行完毕之后，其他线程才可进入
2. 需要同步的代码块使用synchronized同步，提供同步监视器

## 线程安全问题
- 当多个线程并发修改某个竞争资源，会导致线程安全问题
- ThreadLocal：线程局部变量，会把竞争资源，针对每个线程复制一个副本。每个线程要修改竞争资源的时候，修改的是自己拥有的副本。

- 在高并发环境下，可能存在多个线程操作同一个Connection，Connection用完需关闭，不关闭浪费资源，关闭后无法使用。在高并发环境下，不同线程可能拿到同一个connection。

## wait方法与notify、notifyAll方法
- Wait方法可以让线程处于等待状态，notify用于唤醒单个线程，notifyAll用于唤醒所有线程

# 线程池
- 系统启动一个新线程成本比较高，因为涉及到与操作系统交互。这种情形下，使用线程池可以很好提高性能，当程序中需要创建大量生存期很短暂的线程时，更应考虑使用线程池

# 线程组
- Java使用ThreadGroup表示线程组，可以对一批线程进行分类管理，Java允许线程直接对线程组进行控制，一旦某个线程加入指定线程组后，线程将一直属于该线程组，直到线程死亡，线程运行中途不能改变所属线程组
- 线程组可以对线程进行批量管理，可以用线程组管理该组中所有线程出现的异常

# 后台线程
- 后台线程会最后死亡，java中垃圾回收器就属于后台线程，后台线程也称为守护线程
```java
Thread thread = new Thread();
// 设置为后台线程，最后死亡，不代表最后执行完毕
thread.setDaemon(true);
```

# Collections保证集合线程安全

